Day – 1
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LINUX BASICS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. What is Linux?

Linux is an open-source, Unix-like operating system kernel initially developed by Linus Torvalds in 1991. Unlike proprietary operating systems such as Windows and macOS, Linux is free to use, modify, and distribute. While "Linux" strictly refers to the kernel—the core program that manages hardware resources and system operations—the term is commonly used to describe an entire operating system that combines the Linux kernel with various software tools and utilities.

Key Characteristics:

Open Source: Linux’s source code is freely available, allowing anyone to study, modify, and distribute it.

Portability: Linux runs on a wide range of hardware platforms, from personal computers to mainframes and IoT devices.

Security: Its robust design and active community make Linux one of the most secure operating systems.

Multi-user and Multi-tasking: Linux supports multiple users and processes simultaneously.




	• Concept of an Operating System
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		Most important software that runs on a computer. 
		It manages the computer's 
			memory and 
			processes
			all software and hardware. 
		Allows to communicate with the computer without knowing it's language. 
		
		Your computer's operating system (OS) manages 
			software  
			hardware . 
		Several different programs are running at the same time
			They all need to access your computer's 
				CPU
				memory
				storage. 
		The operating system coordinates this.
		
		The three most common operating systems 
			Microsoft Windows, 
			macOS, and 
			Linux.
	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Salient Features of the Linux Operating System
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		Process management:- 
			OS creates and deletes processes. 
			synchronizes communication among processes.
		Memory management:- 
			allocate and de-allocates  memory space to programs.
		File management:- 
			Manages all the file-related activities such as 
				organization storage
				retrieval
				naming
				sharing
				protection of files.
		Device Management: 
			keeps tracks of all devices. Feature also known as the I/O controller. 
			Allocation and de-allocation of the devices.
		I/O System Management: 
			One of the main objects of any OS is to hide the peculiarities of that hardware devices from the user.
		Secondary-Storage Management: 
			Systems have several levels of storage -
				primary storage, 
				secondary storage
				cache storage. 
			Instructions and data must be stored in primary storage or cache so that a running program can reference it.
		Security:- 
			Security module protects the data and information of a computer system against malware threat and authorized access.
		Command interpretation: 
			Interprets commands given by user 
			acts as system resources to process that commands.
		Networking: 
			A distributed system is a group of processors which do not share memory, hardware devices, or a clock. The processors communicate with one another through the network.
		Job accounting: 
			Keeping track of time & resource used by various job and users.
		Communication management: 
			Coordination and assignment of 
				compilers, 
				interpreters
				another software resource of the various users of the computer systems.

		Protected and Supervisor mode
		Memory management and virtual memory multitasking
		Error detection and handling
		Information and Resource Protection
		
		
		
		
	Popular Linux Distributions
	---------------------------
		A Linux distribution (or distro) combines the Linux kernel with various software packages to create a complete operating system. Different distributions cater to different use cases, from general-purpose computing to specialized tasks like server management or penetration testing.

		4.1. General-Purpose Distributions:

			Ubuntu: 
				User-friendly and beginner-friendly, widely used for desktops and servers.
			Fedora: 
				A cutting-edge distro focused on innovation and open-source principles.
			Debian: 
				Known for its stability and extensive software repository.
			Linux Mint: 
				A popular choice for desktop users due to its ease of use and elegant interface.

		4.2. Server and Enterprise Distributions:

			Red Hat Enterprise Linux (RHEL): 
				Widely used in enterprise environments, with commercial support.
			CentOS: 
				A free, community-supported version of RHEL.
			SUSE Linux Enterprise Server (SLES): 
				Focused on enterprise-grade stability and support.

		4.3. Specialized Distributions:

			Kali Linux: 
				Designed for penetration testing and security auditing.
			Arch Linux: 
				A minimalist distro for advanced users who prefer manual configuration.
			Raspberry Pi OS: 
				Optimized for Raspberry Pi devices.

	
		
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Linux architecture
	https://tecadmin.net/tutorial/linux/linux-architecture/
	
	OS
		Interface between user and  computer hardware. 
		Other software applications run on operating system 
			manage hardware resources on a computer.

	The Linux system basically works on 4 layers. 
		Image in 
		https://tecadmin.net/tutorial/linux/linux-architecture/
			Hardware
				Physical devices attached to the System. 
				For e.g.: 
					Hard disk drive, 
					RAM, 
					Motherboard, 
					CPU etc.
			Kernel
				Kernel is the core component for any (Linux) operating system 
				Directly interacts with the hardware.
			Shell
				Interface 
					takes input 
						from Users 
						sends instructions to the Kernel
					takes the output 
						from Kernel  
						send the result back to output shell.
			Applications
				utility programs which runs on Shell. 
				All application like 
					web browser, 
					media player, 
					text  or etc.
			User
				We users

		Linux
		-----
		Linux is an open-source OS 
		Can be installed on a variety of different types of hardware 
		At the heart of Linux is the kernel. 
		Linux was developed in 
			C and 
			assembly language 
			to run on i386 personal computers
		ported to more hardware than just about any other operating system in history. 
		
		Typically administered from a command line interface (CLI)
			also known as a shell. 
		Besides the kernel, Linux distributions include a 
			collection of Linux software, such as 
				device drivers for accessing and controlling hardware, 
				shared libraries, 
				applications and 
				system daemons, 
					which run the in background and respond to network requests. 
		
				
		The kernel 
		----------
		Special piece of the operating system 
			controls the CPU hardware, 
			allocates memory, 
			accesses data, 
			schedules processes, 
			runs the applications and 
			protects them from each other. 
		First program loaded on the computer when the computer starts up. 
		Most critical pieces of code in the kernel are loaded into protected areas of memory 
			so that they can’t be overwritten 
		
		Understanding user space vs. kernel space
		-----------------------------------------
		Operating systems all execute their kernel in 
			protected and restricted memory 
				called kernel space 
				prevent the kernel from terminating and crashing the system. 
		An application or tool executes in user space. 
		Applications can come from a variety of sources, 
			may be poorly developed or originate unknown sources. 
		By running these applications separate from kernel space, 
			they can’t tamper with the kernel resources and cause the system to panic (crash).

		
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The Kernel, Shell & the Software Tools & Applications
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
THE LINUX FILE SYSTEM
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The Concept of File System

		In Linux/UNIX-like operating systems 
			“everything is a file”. 
		Files represents 
			network device, 
			disk, 
			hardware devices etc. 
		These are known as special files.

		File Types in Linux:
		There are multiple types of files. 
			The first character in file permissions under ls -l commands shows the type of file. 
				(-)
					Regular file 	 
						Text files, 
						image files, 
						executable files
				(d)
					Directory file 	 
					Simple directory or folder contained files
				Special files
				(b)
					Block file 
				(c)
					Character device file 
				(p)
					Named pipe file 
				(l)
					Symbolic link file 
				(s)
					Socket file
					
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The Different Types of Files in the Linux File System
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	“In Linux, everything is a File”.
		ls -ltr: First character there can be
			"-": Normal file or 
				Hard link: Additional name for existing file.
			"d": Normal directory
			"l": symbolic link. Shotcut to a file or directory
			"s": socket. Used to pass 
			"p": Named pipe. Users can't directly work. Additional details to follow
			"c": Character device. Processes character hw communication.
			"b": Block device. Major and monor numbers for controlling dev.
			
	In Unix/Linux
		everything is considered as a file except
			running processes

	Linux system does not differentiate between 
		files and 
		directories
	Directories store other files 
	
	All your hardware components are represented as files 
	System communicates with them using these files.

	Input/output resources such as 
		documents, 
		directories (folders in Mac OS X and Windows), 
		keyboard, 
		monitor, 
		hard-drives, 
		removable media, 
		printers, 
		modems, 
		virtual terminals 
		inter-process communication 
		network communication 
			are streams of bytes defined in files.

	In Linux there are basically three types of files:
		Ordinary/Regular files
			Files data contain text, data or program instructions 
			common type of files on Linux:
			e.g.
				Readable files
				Binary files
				Image files
				Compressed files etc.
		Special files
			Block files : 
				device files that provide buffered access to system hardware components. 
				Provide a method of communication with device drivers through the file system.

				Can transfer a large block of data and information at a given time.
				
				ls -l /dev | grep "^b"

			Character files : 
				Type of device files 
				Provide unbuffered serial access to system hardware components. 
				Provide a way of communication with devices by transferring data one character at a time.

				Listing character files sockets in a directory:

				ls -l /dev | grep "^c"

				Listing block files sockets in a directory
				
				ls -l /dev | grep "^c"

	
	
			Character files : 
				Type of device files 

				provide unbuffered serial access to system hardware components.
				Provides a way of communication with devices by transferring data one character at a time.

				Listing character files sockets in a directory:

				# ls -l /dev | grep "^c"

			Symbolic link files : 
				Reference to another file on the system. 
					can be file or
					directory
				Listing symbolic link sockets in a directory:

				# ls -l /dev/ | grep "^l"
			
				N.B: 
				Symbolic links can be created using ln utility in Linux.
					touch file1.txt
					ln -s file1.txt /home/vilas/file1.txt 
					ls -l /home/vilas/ | grep "^l"

			Pipes or Named pipes : 
				Files that allow inter-process communication 
					connects the output of one process to the input of another.

				A named pipe is a file that is used by two process to communicate with each and it acts as a Linux pipe.

				Listing pipes sockets in a directory:
				
				ls -l | grep "^p"
		
				# mkfifo pipe1
				# echo "This is named pipe1" > pipe1
		
				Above we created a named pipe called pipe1, 
				then we passed some data to it using the echo command, 
				now the shell became un-interactive while processing the input.

				Then we opened another shell and ran the following command.
				
				while read line ;do echo "This was passed-'$line' "; done<pipe1
		
			Socket files : 
				Files that provide a means of inter-process communication
				Can transfer data and information between process running on different environments.

				Sockets provide data and information transfer between process running on different machines on a network.

				For e.g 
					a web browser making a connection to a web server.

				# ls -l /dev/ | grep "^s"
		
				In C
				int socket_desc= socket(AF_INET, SOCK_STREAM, 0 );
					AF_INET is the address family(IPv4)
					SOCK_STREAM is the type (connection is TCP protocol oriented)
					0 is the protocol(IP Protocol)
				To refer to the socket file, use the socket_desc, which is the same as the file descriptor, and use read() and write() system calls to read and write from the socket respectively.

								
		Directories
			Special files 
			store both ordinary and other special files 
			organized on the Linux file system in a hierarchy starting from the root (/) directory.

				Listing sockets in a directory:

				# ls -l / | grep "^d"
			
			
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The Hierarchy of the File System
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Linux File Hierarchy Structure or the Filesystem Hierarchy Standard (FHS) 
	-------------------------------------------------------------------------
		Defines the directory structure and directory contents in Unix-like operating systems.
		Maintained by the Linux Foundation.

		All files and directories appear under the root directory /
			even if they are stored on different physical or virtual devices.
		Some of these directories only exist on a particular system 
			if certain subsystemse. e.g. X Window System, are installed.
		Most of these directories exist in all UNIX operating systems 
		Generally used in all linux/unix in a similar way
		
		1. / (Root) : 
			Primary hierarchy root 
			Root directory of the entire file system hierarchy.
			Every single file and directory starts from the root directory
			By default only root user has the right to write under this directory
			/root is root user’s home directory
				not same as /


		2. /bin : 
			Essential command binaries  
				for all users, e.g., cat, ls, cp.
			Contains binary executables
			Common linux commands used 
				in single-user modes are located under this directory.
					e.g. cp, mv etc.
				by all the users of the system are located here 
					e.g. ps, ls, ping, grep, cp



		3. /boot : 
			Boot loader files, 
			Kernel initrd, vmlinux, grub files are located under /boot
			Example: initrd.img-2.6.32-24-generic, vmlinuz-2.6.32-24-generic

		4. /dev : Essential device files, e.g., /dev/null.
			These include terminal devices, usb, or any device attached to the system.
			Example: /dev/tty1, /dev/usbmon0
			
			What is /dev/null and How to Use It
			-----------------------------------
				/dev/null. 
				It’s a special file that’s present in every Linux system. 
				Unlike most other virtual files, 
					instead of reading, 
					it’s used to write. 
				Whatever you write to /dev/null will be 
					discarded, 
					forgotten into the void. 
				It’s known as the null device in a UNIX system.

				Whenever any command-line utility is run, 
					it generates two outputs. 
					The output goes to stdout 
					error (if generated) goes to stderr. 
				By default, both these data streams are associated with the terminal.

				e.g.
					echo "Hello World" - goes to stdout
					run invalid command
						a;skdj;jo
							errors generated would go to stderror
							
				
				File descriptor: 
					In the UNIX ecosystem, File descriptor are integer values assigned to a file. 
						stdout (file descriptor = 1) and 
						stderr (file descriptor = 2) 
						Using the file descriptor (1 and 2 in this situation), 
							we can redirect the stdout and stderr to other files.

					a;skdj;jo 2> error.txt
						error messages should have gone to stderror.
						stderror will get redirected to error.txt
				Returning back to /dev/null	
					grep -r a /sys/
						Execute above command as a normal user
						This would generate lot of errors (Permission denied error)
					
				grep -r a /sys/ 2> /dev/null
					This way errors will be redirected to /dev/null
					grep result will only include stdout. 
					It will not include errors

			If entire output is useless and you want to dump it
			
			grep -r a /sys/ > /dev/null 2>&1

				grep -r a /sys/ > /dev/null
					This will dump output (stdout) to /dev/null
				2>&1
					This will combine error along with stdout and redirect to /dev/null.
					
				Hence both would be ignored.
				
		5. /etc : 
			Host-specific system-wide configuration files.

			Contains configuration files required by all programs.
			This also contains 
				startup and shutdown shell scripts 
					used to start/stop individual programs.
			e.g.:
				/etc/resolv.conf, 
				/etc/logrotate.conf.

		6. /home : 
			Users’ home directories
			containing 
				saved files, 
				personal settings, etc.

				Home directories for all users to store their personal files.
				e.g.: /home/vilas
				
		7. /lib : 
			Libraries essential for the binaries in 
				/bin/ and 
				/sbin/.

				Library filenames are either ld* or lib*.so.*
				Example: ld-2.11.1.so, libncurses.so.5.7
		
		8. /media : Mount points for removable media such as CD-ROMs (appeared in FHS-2.3).

Temporary mount directory for removable devices.
Examples, /media/cdrom for CD-ROM; /media/floppy for floppy drives; /media/cdrecorder for CD writer


9. /mnt : Temporarily mounted filesystems.

Temporary mount directory where sysadmins can mount filesystems.


	10. /opt : Optional application software packages.
	
Contains add-on applications from individual vendors.
Add-on applications should be installed under either /opt/ or /opt/ sub-directory.



11. /sbin : Essential system binaries, e.g., fsck, init, route.

Just like /bin, /sbin also contains binary executables.
The linux commands located under this directory are used typically by system aministrator, for system maintenance purpose.
Example: iptables, reboot, fdisk, ifconfig, swapon


12. /srv : Site-specific data served by this system, such as data and scripts for web servers, data offered by FTP servers, and repositories for version control systems.

srv stands for service.
Contains server specific services related data.
Example, /srv/cvs contains CVS related data.

13. /tmp : Temporary files. Often not preserved between system reboots, and may be severely size restricted.

Directory that contains temporary files created by system and users.
Files under this directory are deleted when system is rebooted.


14. /usr : Secondary hierarchy for read-only user data; contains the majority of (multi-)user utilities and applications.

Contains binaries, libraries, documentation, and source-code for second level programs.
/usr/bin contains binary files for user programs. If you can’t find a user binary under /bin, look under /usr/bin. For example: at, awk, cc, less, scp
/usr/sbin contains binary files for system administrators. If you can’t find a system binary under /sbin, look under /usr/sbin. For example: atd, cron, sshd, useradd, userdel
/usr/lib contains libraries for /usr/bin and /usr/sbin
/usr/local contains users programs that you install from source. For example, when you install apache from source, it goes under /usr/local/apache2
/usr/src holds the Linux kernel sources, header-files and documentation.


15. /proc : Virtual filesystem providing process and kernel information as files. In Linux, corresponds to a procfs mount. Generally automatically generated and populated by the system, on the fly.

Contains information about system process.
This is a pseudo filesystem contains information about running process. For example: /proc/{pid} directory contains information about the process with that particular pid.
This is a virtual filesystem with text information about system resources. For example: /proc/uptime


Modern Linux distributions include a /run directory as a temporary filesystem (tmpfs) which stores volatile runtime data, following the FHS version 3.0. According to the FHS version 2.3, such data were stored in /var/run but this was a problem in some cases because this directory is not always available at early boot. As a result, these programs have had to resort to trickery, such as using /dev/.udev, /dev/.mdadm, /dev/.systemd or /dev/.mount directories, even though the device directory isn’t intended for such data.Among other advantages, this makes the system easier to use normally with the root filesystem mounted read-only. For example, below are the changes Debian made in its 2013 Wheezy release:

	/dev/.* ? /run/*
	/dev/shm ? /run/shm
	/dev/shm/* ? /run/*
	/etc/* (writeable files) ? /run/*
	/lib/init/rw ? /run
	/var/lock ? /run/lock
	/var/run ? /run
	/tmp ? /run/tmp


	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The Significance of the root & the Other Directories.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	The root folder, also called the root directory or sometimes just the root, of any partition or folder is the "highest" directory in the hierarchy. You can also think of it in general as the start or beginning of a particular folder structure.


	The root directory contains all other folders in the drive or folder, and can, of course, also contain files. You can visualize this with an upside-down tree where the roots (the root folder) are at the top and the branches (subfolders) fall below; the root is what holds together all of its lower items.

	

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Logging into LINUX system
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


Prerequisites
Following are the prerequisites

	Remote computer must be 
		turned on 
		must have a network connection.
	SSH client and server applications need to be installed and enabled.
	
	You should have the 
			IP address or 
			the name of the 
		remote machine you want to connect to.
		
	You need to have the necessary permissions to access the remote computer.
	Firewall settings need to allow the remote connection
	
	
	What is SSH?
	------------
	Secure Shell / Secure Socket Shell
		A protocol which allows you to connect securely to a remote computer or a server by using a text-based interface.

		When a secure SSH connection is established, 
			a shell session will be started
			we will be able to manipulate the server by typing commands within the client on your local computer.

	How Does SSH Work?
	-------------------
	To establish an SSH connection
	we need two components: 
		a client and 
		corresponding server-side component. 
	An SSH client 
		an application you install on the computer 
		we use it to connect to another computer or a server. 
	The client uses the provided remote host information to initiate the connection 
		if the credentials are verified, establishes the encrypted connection.

	On the server’s side, there is a component called an SSH daemon 
		that is constantly listening to a specific TCP/IP port (default:22) for possible client connection requests. 
	Once a client initiates a connection
		SSH daemon will respond with the software and the protocol versions it supports 
	Two will exchange their identification data. 
	If the provided credentials are correct, 
		SSH creates a new session for the appropriate environment.

	The default SSH protocol version for SSH server and SSH client communication is version 2.





	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	10. /opt : Optional application software packages.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Linux Boot Process – various stages during booting
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Linux boot process involves a series of stages to bring the system up and running. Here's a breakdown of the key steps:   

1. Power-On Self-Test (POST)

	Initiated by BIOS/UEFI: When the computer is powered on, the BIOS (Basic Input/Output System) or UEFI (Unified Extensible Firmware Interface) takes control.   
	Hardware Checks: POST performs a series of tests on the system's hardware components (CPU, RAM, hard drive, etc.) to ensure they are functioning correctly.   
	Boot Device Selection: Based on the boot order in the BIOS/UEFI settings, it determines the boot device (usually the hard drive).
2. Boot Loader

	Loading the Boot Loader: The BIOS/UEFI loads the boot loader from the boot device (typically located in the Master Boot Record (MBR) or the GUID Partition Table (GPT)). Common boot loaders include GRUB (Grand Unified Bootloader) and LILO (Linux Loader).   
	Boot Loader Functions:
	Kernel Loading: The boot loader locates the Linux kernel image on the hard drive and loads it into memory.   
	Kernel Parameters: It may allow the user to pass kernel parameters (e.g., boot options, kernel debugging flags) during the boot process.   
	Kernel Transfer: The boot loader transfers control to the loaded Linux kernel.
3. Kernel Initialization

	Kernel Startup: The Linux kernel begins its initialization process.   
	Hardware Initialization: The kernel initializes hardware devices (e.g., CPU, memory, disk drives, network interfaces) and loads necessary drivers.   
	Filesystem Initialization: The kernel mounts the root filesystem, which contains the core system files and user data.   
4. Init Process

	init Process: The kernel starts the init process, which is the first process to run in the Linux system.
	Runlevel Management: init is responsible for setting the system's runlevel, which determines the services and processes that are started.
	Runlevels: Different runlevels define different system states (e.g., single-user mode, multi-user mode, graphical mode).   
5. System Startup

	Service Startup: init or its successor (like systemd) starts system services (daemons) such as network services (SSH, DHCP), file systems, and graphical display managers.
	User Login: Once the system is ready, users can log in to their accounts.
6. User Interface

	Graphical User Interface (GUI): If a graphical desktop environment is installed, the display manager starts and presents the user with a login screen.
	Command-Line Interface (CLI): In text-based environments, users can log in directly to a command-line prompt.   

Key Points:

	The boot process involves a complex interplay between hardware and software components.   
	The specific steps and their order may vary slightly depending on the Linux distribution and system configuration.
	The boot loader plays a crucial role in the booting process, selecting the kernel and providing initial parameters.



	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Various run-levels using init command
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The init command and its associated runlevels are a core concept in older Linux distributions. However, with the rise of systemd, the traditional runlevels have become less prominent.

Here's a breakdown of the common runlevels associated with the init command:

Runlevel 0: Halt - Shuts down the system completely.
Runlevel 1: Single-user Mode - A maintenance mode with limited functionality. Networking is typically disabled, and only the root user can log in.
Runlevel 2: Multi-user Mode - Similar to Runlevel 3, but with networking disabled.
Runlevel 3: Multi-user Mode with Networking - The standard runlevel for most systems. Allows multiple users to log in and provides full network connectivity.
Runlevel 4: User-definable - Can be customized for specific system needs.
Runlevel 5: Graphical Mode - Starts the X Window System for a graphical user interface.
Runlevel 6: Reboot - Restarts the system.
Important Notes:

Systemd: In modern Linux distributions, systemd has largely replaced init as the process manager.
Target States: systemd uses "target states" instead of traditional runlevels. These target states (e.g., multi-user.target, graphical.target) provide a more flexible and descriptive way to define system states.
Runlevel 3 is often the default runlevel in older systems.
While the concept of runlevels is still relevant, it's important to understand that the implementation and usage may vary significantly between different Linux distributions.

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	• Starting the system in Single User mode
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


GRUB and systemd-boot: These are common boot loaders used in Linux systems.
Edit Boot Options: You need to access the boot options during the startup process.
Append "single": Adding the word "single" to the kernel command line instructs the system to boot into single-user mode.
Save and Boot: After modifying the boot options, you need to save the changes and proceed with the boot process.
Note:

The exact steps and key combinations might vary slightly depending on the specific bootloader and Linux distribution.
Booting into single-user mode provides access to the system with root privileges for maintenance and troubleshooting.
It's crucial to proceed with caution in single-user mode as changes made in this mode can have significant system-wide effects.
I hope this helps! Let me know if you have any other questions.
1. During Boot Process:

GRUB (Grand Unified Boot Loader):

If you're using GRUB, at the GRUB boot prompt, press the "e" key to edit the boot options.
Locate the line starting with "linux" or "linuxefi".
Append the word "single" to the end of that line.
Press Ctrl+x to save the changes and boot into single-user mode.
systemd-boot:

If you're using systemd-boot, press the "e" key at the systemd-boot prompt.
Locate the line starting with "linux" or "linuxefi".
Append "single" to the end of that line.
Press Ctrl+x to save the changes and boot into single-user mode.
2. After Boot (if you have access to a console):

If you can already access a running system, you can often reboot into single-user mode by pressing a specific key during the boot process (usually Ctrl+Alt+Del or Ctrl+Alt+F1). The exact key combination varies depending on the system and its configuration.
Key Points:

Single-user mode provides a way to access and repair the system without the usual graphical interface or network services.
It's often used for system administration tasks, troubleshooting, and recovering from system failures.
Be cautious when working in single-user mode, as you have direct access to the system and can potentially cause damage if not done carefully.

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	• Accessing help using man, info, what is and -- help.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

1. man (Manual Pages)

Purpose: Provides comprehensive, detailed information about commands, system calls, libraries, and other system components.
Usage: man <command_name>
Example: man ls (displays the manual page for the ls command)
Key Features:
Detailed descriptions of command usage, options, and examples.
Often includes a SYNOPSIS section summarizing the command's syntax.
Can be lengthy and may require navigation within the manual page.
2. info

Purpose: An alternative to man for accessing online documentation.
Usage: info <command_name>
Example: info ls
Key Features:
Uses a hypertext-like format for easier navigation.
Often provides more extensive documentation than man for some commands.
May require the installation of the info package.
3. whatis

Purpose: Provides a short, one-line description of a command or function.
Usage: whatis <command_name>
Example: whatis ls (displays a brief description of the ls command)
4. --help (Built-in Help)

Purpose: Many commands have a built-in --help option that provides a concise summary of the command's usage and available options.
Usage: <command_name> --help
Example: ls --help
In Summary:

man: The most comprehensive source for detailed information about commands.
info: An alternative to man with hypertext-like navigation.
whatis: Provides a quick overview of a command.
--help: Offers a brief, built-in summary of a command's usage.

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	• Basic commands: pwd, date, clear, ls, cal, who
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		ls folder
		pwd 
		
		ls: Lists files and directories in the current directory.
		ls -l: Lists files with detailed information (permissions, owner, size, etc.).
		ls -a: Lists all files and directories, including hidden files (starting with a dot).
		ls -lh: Lists files with human-readable sizes (e.g., 1.5M instead of 1536000).

		who -H - Show header in 'who' command output
    
1. date

date: Displays the current date and time.
date +%Y-%m-%d: Displays the date in YYYY-MM-DD format.
date +%H:%M:%S: Displays the time in HH:MM:SS format.
date "+%Y-%m-%d %H:%M:%S": Displays both date and time in a combined format.
date -u: Displays the date and time in UTC (Coordinated Universal Time).
date --set="2024-07-04 10:00:00": Sets the system date and time (requires root privileges).
2. clear

clear: Clears the terminal screen.
reset: Clears the screen and resets terminal settings (colors, attributes, etc.).
3. ls

ls: Lists files and directories in the current directory.
ls -l: Lists files with detailed information (permissions, owner, size, etc.).
ls -a: Lists all files and directories, including hidden files (starting with a dot).
ls -h: Displays file sizes in a human-readable format (e.g., 1K, 2M, 1G).
ls -R: Recursively lists files and directories in the current directory and all subdirectories.
ls -t: Sorts files by modification time (newest first).
4. cal

cal: Displays the calendar for the current month.
cal <month> <year>: Displays the calendar for a specific month and year (e.g., cal 7 2024).
cal <year>: Displays the calendar for the entire year.
5. who

who: Displays a list of currently logged-in users.
who -u: Displays more detailed information about logged-in users, including login time and terminal	


		
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Wild card characters: *,?,[],^,-
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Wildcards are special characters used in file and directory names to represent a set of characters or any number of characters. Here's a breakdown of the common wildcards and their usage:

* (Asterisk)

	Matches any sequence of characters (including zero characters).
	Examples:
	ls * : Lists all files and directories in the current directory.
	rm *.txt : Deletes all files ending with ".txt".
	? (Question Mark)

Matches any single character.
Examples:
	ls f?.txt : Lists files starting with "f", followed by any single character, and ending with ".txt".
	ls my_file_?.txt : Matches files like "my_file_1.txt", "my_file_a.txt", etc.
	[] (Square Brackets)

Matches any single character within the brackets.
Examples:
	ls f[oa]t.txt : Matches "fat.txt" and "fot.txt".
	ls f[0-9].txt : Matches files starting with "f", followed by a single digit (0-9), and ending with ".txt".
	^ (Caret within square brackets)

Matches any character not within the brackets.
Example: ls f[^a-c].txt : Matches files starting with "f", followed by any character except "a", "b", or "c", and ending with ".txt".
	- (Hyphen within square brackets)

Specifies a range of characters.
	Example: ls f[a-z].txt : Matches files starting with "f", followed by any lowercase letter, and ending with ".txt".
Important Notes:

These wildcards are often used with commands like ls, rm, cp, mv, and find.
Be cautious when using wildcards, especially with commands like rm, as they can unintentionally delete or modify multiple files.
The specific behavior of wildcards may vary slightly depending on the shell you are using (e.g., Bash, Zsh).

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Managing directories: mkdir, cd, rmdir, $HOME, ~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		mkdir command 
			Used for creating new directories/folder on Unix/Linux systems.
			Refer mkdir folder
			mkdir new_directory: Creates a new directory named "new_directory".
			mkdir -p dir1/dir2/dir3: Creates directories recursively.
			
		
		cd
			“change directory”. 
			
			cd <Path to new dir>
				Path
					absolute path
					relative path

			
			Special notation 
				Following works with most commands including cd.
				"."	: Current directory
					cd ./abc/
				"..": Parent directory	
				"~"	:	home directory
				"–"	: 	previos directory
				
				
				cd ..: Moves to the parent directory.
				cd /: Moves to the root directory.
				cd /home/user: Moves to the home directory of user.
				cd Documents: Moves to the "Documents" directory in the current directory.

		rmdir
			rmdir empty_dir: Removes an empty directory named "empty_dir".
			rmdir -p dir1/dir2/dir3: Removes directories recursively if they are empty.
			
		$HOME 
			~
			
			
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Using absolute and relative path method for changing directories
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	cd /home/user - absolute
	cd user - relative 
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LINUX VI  OR
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Working modes in vi  or
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To open a file with vi, use the following command:

vi filename

	If the file exists, vi will open it for editing.
	If the file does not exist, vi creates a new file with the specified name.

4. Navigating in vi

Once in Command Mode, use the following keys to navigate:

4.1 Moving the Cursor

	h: Move left
	l: Move right
	j: Move down
	k: Move up

4.2 Word Navigation

	w: Move to the beginning of the next word.
	e: Move to the end of the current/next word.
	b: Move to the beginning of the current/previous word.

4.3 Line Navigation

	0: Move to the beginning of the current line.
	^: Move to the first non-whitespace character on the current line.
	$: Move to the end of the current line.
4.4 Scrolling

	Ctrl-d: Scroll down half a screen.
	Ctrl-u: Scroll up half a screen.
	Ctrl-f: Scroll forward one full screen.
	Ctrl-b: Scroll backward one full screen.

5. Switching to Insert Mode

	To start inserting or editing text, switch to Insert Mode by pressing:

	i: Insert text before the current cursor position.
	I: Insert text at the beginning of the current line.
	a: Append text after the current cursor position.
	A: Append text at the end of the current line.
	o: Open a new line below the current line and insert text.
	O: Open a new line above the current line and insert text.

To return to Command Mode, press Esc.

6. Saving and Exiting

	In Ex Mode, you can save and exit using the following commands:

	:w: Save the file without exiting.
	:q: Exit if no changes have been made.
	:wq or :x: Save and exit.
	:q!: Quit without saving changes.

7. Deleting Text

	In Command Mode, use the following commands to delete text:

	x: Delete the character under the cursor.
	X: Delete the character before the cursor.
	dd: Delete the current line.
	d$: Delete from the cursor to the end of the line.
	d0: Delete from the cursor to the beginning of the line.

8. Copying and Pasting Text

	vi uses registers for copying and pasting text:
	yy: Copy (yank) the current line.
	yw: Copy from the cursor to the end of the word.
	y$: Copy from the cursor to the end of the line.
	p: Paste the copied text after the cursor.
	P: Paste the copied text before the cursor.

9. Searching and Replacing Text

9.1 Searching

	/pattern: Search for pattern forward.
	?pattern: Search for pattern backward.
	n: Repeat the search in the same direction.
	N: Repeat the search in the opposite direction.

9.2 Replacing

	:s/old/new/: Replace the first occurrence of old with new on the current line.
	:s/old/new/g: Replace all occurrences of old with new on the current line.
	:%s/old/new/g: Replace all occurrences of old with new in the entire file.
	:%s/old/new/gc: Replace all occurrences with confirmation for each change.

10. Undo and Redo

	u: Undo the last change.
	U: Undo all changes on the current line.
	Ctrl-r: Redo the undone change.

11. Advanced Features

11.1 Working with Multiple Files
	:e filename: Open another file in vi.
	:n: Move to the next file.
	:prev: Move to the previous file.

11.2 Splitting Windows

	:split filename: Open a file in a new split window.
	Ctrl-w: Switch between split windows.

11.3 Recording Macros
	q<register>: Start recording a macro into a register (e.g., qa).
	Perform the actions you want to record.
	q: Stop recording.
	@<register>: Play back the recorded macro.

12. Customizing vi

	You can customize vi through the .vimrc (or .exrc) configuration file. Examples:
	Enable line numbers:
	set number
	Enable syntax highlighting:
	syntax on
	Set auto-indentation:
	set autoindent
	:set paste 
		retain the paste formating

13. Tips and Best Practices

	Practice frequently to become familiar with commands.
	Use :help within vi to access detailed documentation.
	Create backups of configuration files before editing.
	Customize your .vimrc for a personalized editing experience.

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Creating text files
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
already covered
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Save and quit commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

already covered	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Text   mode commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

already covered	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Cursor movement commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

already covered	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Text deletion commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

already covered	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Replacing text commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

:%s/old_text/new_text/g
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	•  /Cut & Paste commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

already covered		
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Other miscellaneous commands in vi  or
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
already covered		
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MANAGING FILES & DIRECTORIES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Creating empty files: touch
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	touch command is used to 
		create empty files 
	or 
		change time stamp for existing files
		
		touch newfile.txt
		ls -ltr
		touch existingfile.txt
		ls -ltr
		
		
		
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Displaying contents of file: cat
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		Linux cat command is used to 
			display file content
			create new files 
			  file contents to other files.
			
			
			Refer cat directory (more detailed)
				cat file1.txt: Displays the contents of "file1.txt" on the screen.
				cat file1.txt file2.txt > output.txt: Concatenates the contents of "file1.txt" and "file2.txt" and redirects the output to "output.txt".
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	•  ing files and directories: cp
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		cp file1.txt new_file1.txt: Copies "file1.txt" to "new_file1.txt".
		cp -r dir1 dir2: Recursively copies the directory "dir1" to "dir2".
		cp -R equivalent to cp -r 
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Removing files: rm
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		rm file1.txt: Deletes the file "file1.txt".
		rm -r dir1: Recursively deletes the directory "dir1" and all its contents.
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Renaming Files and directories: mv
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		mv file1.txt new_location/: Moves "file1.txt" to the "new_location" directory.
		mv file1.txt new_filename.txt: Renames "file1.txt" to "new_filename.txt".
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• File locating command: find
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	find (Search for Files and Directories)
		find . -name "filename.txt": Searches for the file named "filename.txt" in the current directory and its subdirectories.
		find . -type f: Finds all files (not directories) in the current directory and its subdirectories.

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Sorting file contents: sort
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Extracting specific characters and fields: cut
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		Used to extract the specific column from a file. 
		Define the column number and column delimiter with command.
		
		cut -d<delimiter> -f<field1,field2,...> filename
			-d: delimiter
			-f: column number
		
		To extract 1st and 6th column from /etc/passwd file.
			cut -d":" -f1,6 /etc/passwd
			
		-f can be a range too
			cut -d":" -f1-4,6 /etc/passwd
			cut -d":" -f1-3,5-7 /etc/passwd
			
			
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Other commands 
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			
	less (View File Content Page by Page)
		less file1.txt: 
			Displays the contents of "file1.txt" one screen at a time, allowing you to scroll through the file.
	
	head (Display the Beginning of a File)
		head -n 10 file1.txt: Displays the first 10 lines of "file1.txt".
	
	tail (Display the End of a File)
		tail -n 10 file1.txt: Displays the last 10 lines of "file1.txt".
		tail -f logfile.txt: Continuously displays the latest lines added to "logfile.txt".
	
	
	man (Display the Manual Page for a Command)
		man ls: Displays the manual page for the "ls" command.


	kill (Terminate Processes)

		kill <process_id>: Sends a signal to the process with the specified ID to terminate it.
		kill -9 <process_id>: Sends a stronger signal (SIGKILL) to the process to force its termination.
	top (Monitor System Processes and Resources)

		top: Displays a dynamic view of the currently running processes, CPU usage, memory utilization, and other system information.


	tar (Archive Files)

		tar -cvzf archive.tar.gz file1.txt file2.txt: Creates a compressed tar archive named "archive.tar.gz" containing "file1.txt" and "file2.txt".
		tar -xvf archive.tar 
		tar -xvfz archive.tar.gz: Extracts the contents of "archive.tar.gz".
		

	df
		* Purpose: Displays disk space usage.
		* Example: df -h (displays disk space usage in human-readable format)
		Details:
			This command displays the available and used disk space on all mounted filesystems in a human-readable format (e.g., GB, MB).
		How it works:
			It retrieves filesystem information and formats it for display.
		Options:
			-T: Include the filesystem type.
		 
		df -hT
			df -hT - Display disk space usage with filesystem type
		df -i
			-i: Show inode usage instead of disk space.
	 
	

	du
		* Purpose: Estimates file and directory space usage.
		* Example: du -sh (displays disk usage in human-readable format for the current directory and its subdirectories)
		du - Estimate File and Directory Space Usage
		Command Example:
		 
		 
		 
		du -h
		Details:
			This command estimates the disk space usage of files and directories, showing sizes in human-readable format.
			How it works:
			It traverses the directory structure and calculates the size of each file and directory.
			Options:
			-d 1: Display the size of directories one level deep.
			du -h -d 1
				Display the size of the directories in the current directory
			-s: Show only the total size.
			
			 
			du -sh


	free
		* Purpose: Displays system memory usage (total, used, free, etc.).

	ifconfig
		* Purpose: (Older command) Configure and display network interface information.
		* Note: ip command is generally preferred in newer systems.


	netstat
		* Purpose: Display network statistics and connections.
		* Example: netstat -an (displays all network connections)

	scp
		* Purpose: Securely   files between local and remote systems.
		* Example: scp local_file.txt user@remote_server:/path/to/remote/directory
		scp - Securely   Files Between Local and Remote Systems
		Command Example:
		 
		 
		 
		scp file.txt user@remote_server:/path/to/destination
		Details:
		This command copies file.txt from the local system to the specified path on the remote server.
		How it works:
		Uses SSH for secure file transfer.
		Options:
		-r:   directories recursively.
		 
		 
		 
		scp -r /local/directory user@remote_server:/remote/destination



	wget
		* Purpose: Download files from the internet.
		* Example: wget http://example.com/file.zip

	curl
		* Purpose: 
			Transfer data with URLs (more versatile than wget, can handle various protocols like HTTP, HTTPS, FTP).

	shutdown
		* Purpose: Shutdown or restart the system.
		* Example: shutdown -h now (shuts down the system immediately)

	reboot
		Purpose: Restart the system.
		reboot -h now - Reboot the system immediately
    
	uname
		* Purpose: Display system information (kernel name, hostname, etc.).
		uname -a
			The output 
				MINGW64_NT-10.0-22631 LAPTOP-BUA2IBR3 3.4.10-87d57229.x86_64 2024-02-14 20:17 UTC x86_64 Msys from the uname -a command provides information about your system:

			MINGW64_NT-10.0-22631: 
				This indicates that you are using the MinGW-w64 environment
					a port of the GNU Compiler Collection (GCC) to the Windows operating system.

			MINGW64: 
				Stands for "Minimalist GNU for Windows 64-bit."
			NT-10.0-22631: 
				Refers to the Windows NT version, specifically Windows 10, with build number 22631.
			LAPTOP-BUA2IBR3: 
				This is the hostname of your computer.

			3.4.10-87d57229.x86_64: 
				This is the kernel version.

			3.4.10: 
				The major, minor, and patch version of the kernel.
			-87d57229.x86_64: 
				A specific build or revision number, along with the architecture (x86_64, indicating 64-bit).
			2024-02-14 20:17 UTC: 
				This is the date and time the kernel was compiled.

			x86_64: 
				This indicates the system architecture (64-bit).

			Msys: 
				This signifies that you are using the MSYS2 environment, which provides a more comprehensive set of tools and libraries for developing with MinGW-w64 on Windows.

	who
		* Purpose: Display currently logged-in users.
	whoami

	history
		* Purpose: Display a list of previously executed commands.

	alias
		* Purpose: Create shortcuts for frequently used commands.
		* Example: alias ll='ls -l' (creates an alias "ll" for the command "ls -l")

	ps aux
		* Purpose: 
			Display detailed information about running processes (user, CPU usage, memory usage, etc.).

	
	
	gzip - Compress Files
	Command Example:
		gzip filename.txt
		Details:
			This command compresses the file filename.txt into a .gz file (filename.txt.gz) to save disk space.
		How it works:
			gzip uses a compression algorithm to reduce the file size.
			The original file is replaced with the compressed .gz version.
		Options:
			-v: Verbose mode; displays compression details.
		gzip -v filename.txt
			-k: Keep the original file after compression.
		gzip -k filename.txt


	unzip - Extract Files from a ZIP Archive
	Command Example:
		unzip archive.zip
		Details:
			This command extracts the contents of archive.zip into the current directory.
		How it works:
		It reads the ZIP archive and decompresses its contents.
		Options:
			-l: List the contents of the ZIP file without extracting.
		unzip -l archive.zip
			unzip -l - List the contents of a ZIP archive
		unzip -d 
			-d: Extract the contents to a specific directory.
			unzip archive.zip -d /path/to/destination


Add the below commands also 
	echo - Display a message or value
    sort - Sort lines of text files
    
	which - Show the full path of a command
    whois - Look up domain registration information
    nc - Network utility for reading/writing data across networks
    ssh-keygen - Generate SSH key pairs
    
    ln -s - Create symbolic links to files or directories
    time - Measure the execution time of a command
    
	ps -aux | grep "process" - Search for a specific process
    du -s - Display only the total size of a directory
    
	history -c - Clear command history
    sudo !! - Re-run the last command with sudo
    
	locate - Find files by name
    ps -eLf - Display threads for all processes
    
    du -h -d 1 - 
    
	zip -r - Create a ZIP archive recursively
    zip -d - 
		Remove files from a ZIP archive
    ps -e | awk '{print $1}'  | sort pcpu 
		filter command output using awk 
	lsof -i - Display information about open internet connections
    killall - Signal processes by name
    top -u username - Monitor resource usage for a specific user
    
	

 
 
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Lab session
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Day – 2
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
MANAGING FILES & DIRECTORIES (cont’d)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• File comparing commands: cmp, comm, diff, patch
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


1 cmp compares two files byte by byte and reports the first point of difference.

Syntax:

cmp [options] file1 file2
Example:
	cmp file1.txt file2.txt

Output:

If the files differ, cmp displays the byte and line number where the first difference occurs.

If the files are identical, there is no output.

Common Option:

-l: Lists all differing bytes.

2. comm

comm compares two sorted files line by line and displays three columns:

Lines unique to the first file.

Lines unique to the second file.

Lines common to both files.

Syntax:

comm [options] file1 file2

Example:

comm file1.txt file2.txt

Common Options:

-1: Suppress lines unique to the first file.

-2: Suppress lines unique to the second file.

-3: Suppress lines common to both files.

3. diff

diff displays the differences between two files line by line. It is more descriptive and widely used for text comparison.

Syntax:

diff [options] file1 file2

Example:

diff file1.txt file2.txt

Output:

Differences are shown with line numbers and markers (< for file1, > for file2).

Common Options:

-u: Unified format, displaying changes in context.

-c: Context format, showing more detailed differences.

4. patch

patch applies changes to a file using a patch file, typically generated by diff.

Syntax:

patch [options] original_file patch_file

Example:

Generate a patch file:

diff -u file1.txt file2.txt > changes.patch

Apply the patch:

patch file1.txt < changes.patch

Output:

The original file is updated with the changes specified in the patch.

Common Options:

-pN: Strips N leading components from file paths in the patch file.

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• File utilities: wc, join
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Purpose: Counts the number of lines, words, and characters in a file.

Syntax: wc [OPTION]... [FILE]...

Common Options:

-l: Counts the number of lines.
-w: Counts the number of words.
-c: Counts the number of characters.
-L: Prints the length of the longest line.
-m: Counts the number of characters (same as -c).
--files0-from=FILE: Reads input from the list of files delimited by the null character.
Examples:

wc myfile.txt: Displays the number of lines, words, and characters in "myfile.txt".
wc -l myfile.txt: Displays only the number of lines in "myfile.txt".
wc -w myfile.txt: Displays only the number of words in "myfile.txt".
wc -c myfile.txt: Displays only the number of characters in "myfile.txt".
wc -L myfile.txt: Displays the length of the longest line in "myfile.txt".
join

Purpose: Joins lines from two files based on a common field.

Syntax: join [OPTION]... FILE1 FILE2

Common Options:

-1 FIELD: Specifies the field number to join on in FILE1.
-2 FIELD: Specifies the field number to join on in FILE2.
-a FILE: Display unpairable lines from FILE.
-e FIELD: Replace missing fields with FIELD.
-o FORMAT: Output fields in the specified format.
Example:

Let's say you have two files:

file1.txt: Contains a list of IDs and names (e.g., "1 John", "2 Jane", "3 David")
file2.txt: Contains a list of IDs and ages (e.g., "1 25", "2 30", "3 28")
To join these files based on the ID:

Bash

join -1 1 -2 1 file1.txt file2.txt
This command will join the lines in file1.txt and file2.txt based on the first field (ID) in each file, producing an output like:

1 John 25
2 Jane 30
3 David 28

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Pattern locating command: grep, fgrep, egrep
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	grep: “Global Regular Expression Print“. 
	Used for searching content from files based on a pattern or regular expression.

			Synatx:
			grep "PATTERN" [FILE]
			
		1. Search all users under /etc/passwd have the   shell.
			grep " " /etc/passwd

		2. Grep command can take the output of another command as input using pipes. 
		
			cat /etc/passwd | grep " "
			
			
		3. Case Sensitive Search
			Grep uses -i option to run NOT case-sensitive search.
			grep -i "SearchPattern" filename
			grep -i " " /etc/passwd

		4. Search Recursively 
			Using the -r switch grep to search for pattern recursively for all files under the specified directory and their subdirectories.

			grep -r "SearchPattern" <directory>
			grep -r " " /etc
			sudo grep -r " " /etc
			
		5. Print Matching Filename Only
			The default grep prints the matching content on the output with the respective file names. You can hide the content and display only filename in grep output.

			Use -l to print pattern matching filenames.

			grep -rl "SearchPattern" /home/rahul
			Use -L to revert the output. This will print only those file where no match found.

			grep -rL "SearchPattern" /home/rahul
			Print Before/After Lines of Matching Pattern
			This is a useful feature of grep command. You can print the defined number of lines just before line matches the pattern or just after lines of matches pattern.

			Use -A followed by number of lines to print lines before the matching pattern line.

			grep -A2 "SearchPattern" myfile.csv
			Use -B followed by number of lines to print lines after the matching pattern line.

			grep -B2 "SearchPattern" myfile.csv
			Use -C followed by number of lines to print lines before and after the matching pattern line.

			grep -B2 "SearchPattern" myfile.csv
			Tagsgrep, grep command, linux command
			Doc navigation← Linux - teeLinux - wc →

	
		
			grep -v "pattern" - Inverse search; display lines that do not match the pattern
			
			grep -C 2 "pattern" - Display lines before and after the matched pattern
			
			grep -rli "pattern" . - Search for a pattern in files and display matching filenames only
		
	
	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Translate : tr
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Purpose:

It's a command-line utility used to translate or delete characters from standard input (or a file) and write the results to standard output.
It can be used for various text manipulation tasks, such as:
Character translation: Replace one set of characters with another.
Character deletion: Remove specific characters from input.
Character squeezing: Replace multiple occurrences of a character with a single occurrence.
Basic Syntax:

Bash

tr [OPTION]... SET1 SET2
SET1: Specifies the set of characters to be translated or deleted.
SET2: Specifies the set of characters to be substituted for the characters in SET1. If SET2 is shorter than SET1, the last character in SET2 is repeated.
Common Options:

-d: Delete characters in SET1.
-s: Squeeze repeated characters in SET1.
-c: Complement SET1 (translate or delete characters not in SET1).
-t: Same as -s (squeeze repeated characters).
-squeezeset: Squeeze repeated characters in SQUEEZESET.
Examples:

Translate lowercase letters to uppercase:

Bash

echo "hello world" | tr 'a-z' 'A-Z' 
Delete all vowels:

Bash

echo "hello world" | tr -d 'aeiouAEIOU'
Replace all spaces with underscores:

Bash

echo "hello world" | tr ' ' '_'
Squeeze multiple spaces into a single space:

Bash

echo "hello   world" | tr -s ' ' 

	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Lab session
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
INPUT/OUTPUT REDIRECTION & PIPES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Concepts of file descriptors: Standard input, output and error files
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Redirection symbols: <, >, >>
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Input redirection
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Output redirection
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Error redirection
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Usage of pipes and tee command
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Used to route output data to multiple outputs. 
	For e.g. Tee can display output on STDOUT as well ass write to file at a time.
	
	1. The following command will 
		display list of files in current directory on screen and
		write in list.txt file.

		ls | tee list.txt
		
	2. Append Data to File
		The default tee overwrites the file content. You can use -a to append data to file.

		ls | tee –a list.txt
		
	3. Write data to Multiple File
		You can also write the output to multiple files in a single command. The example is below

		ls | tee list1.txt list2.txt



	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Lab session
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FILE ACCESS PERMISSIONS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Permission Groups
		Each file and directory has three user based permission groups:

		owner – 
			The Owner permissions 
				apply only to the owner of the file or directory, 
				will not impact the actions of other users.
		group – 
			The Group permissions 
				apply only to the group that has been assigned to the file or directory
				will not effect the actions of other users.
		all users – 
			All Users permissions 
				apply to all other users on the system
				Be cautious of this from a security point of view.

	Permission Types
		Each file or directory has three basic permission types:

		read – 
			User’s capability to read the contents of the file.
		write
			User’s capability to write or modify a file or directory.
		execute – 
			User’s capability to execute a file or 
			view the contents of a directory.


	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Long listing of files: ls -l
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	View the permissions by executing “ls -l” command 
		Will list files in current directory

		The permission in the command line is displayed as: _rwxrwxrwx 1 owner:group

		First Character: User rights/Permissions
			(_ here) is the special permission flag that can vary.
		The following set of three characters (rwx) 
			owner permissions.
		The second set of three characters (rwx) 
			Group permissions.
		The third set of three characters (rwx) 
			All Users permissions.
		Following that grouping since the integer/number 
			displays the number of hardlinks to the file.
		last piece 
			Owner and Group assignment formatted as Owner:Group.


	
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Types of users: owner, group and others
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Types of permissions: read, write and execute
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Changing file access permission: chmod
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	Modifying the Permissions
		From command line, 
			the permissions are  ed by using the command chmod. 
			You can assign the permissions explicitly or by using a binary reference as described below.

		Explicitly Defining Permissions
		-------------------------------
		To explicity define permissions 
			we define the permission for Permission Group and Permission Types.

		The Permission Groups used are:
			u – Owner
			g – Group
			o – Others
			a – All users

		The potential Assignment Operators are 
			+ (plus) and 
			– (minus); 
			these are used to tell the system whether to add or remove the specific permissions.

		The Permission Types that are used are:

		r – Read
		w – Write
		x – Execute
		
		If file file1 currently has the permissions 
			_rw_rw_rw, 
				owner, 
				group  
				all users 
					all have read and write permission. 
		To remove the read and write permissions from the all users group.
			chmod a-rw file1
		To add the permissions above you would invoke the command: 
			chmod a+rw file1


		Using Binary References To Set Permissions
		------------------------------------------
		Another option to set the permission 
			using binary references 

		__rw_rw_rw
		 011011011
		3	3	3

		First number 
			represents the Owner permission; 
		second represents 
			the Group permissions; 
		last number represents 
			the permissions for all other users. 

		r = 4
		w = 2
		x = 1
		You add the numbers to get the integer/number representing the permissions you wish to set. You will need to include the binary permissions for each of the three permission groups.

		To set a file to permissions on file1 to read 
			_rwxr_____, 
			 7	4	0 
			 
			chmod 740 file1 




		Owners and Groups
		-----------------
		Owner and Group assigned to a file or directory can be modified.

		chown command 
			Used to change owner and group assignments
		
			chown owner:group filename
			
		so to change the owner of file1 to user1 and the group to dev  
			chown user1:dev file1.

		Advanced Permissions
		--------------------
		The special permissions flag can be marked with any of the following:

		"_": no special permissions
		d:	directory
		l: 	The file or directory is a symbolic link
		s:	setuid/setgid permissions. 
			Not set displayed in the special permission part of permissions display, 
			Represented as s in the read portion of the owner or group permissions.
		t – indicates the sticky bit permissions. 
			Not set displayed in the special permission part of the permissions display
			Represented as t in the executable portion of the all users permissions
		
		chmod +x filename - Make a file executable
    
		
		Setuid/Setgid Special Permissions
		---------------------------------
		setuid/setguid permissions 
			used to tell the system to run an executable as the owner with the owner’s permissions.
			This was we can allow users execute few commands with escalated privilege without giving sudo privilege.
			
		Be careful using setuid/setgid bits in permissions. 
		If you incorrectly assign permissions to a file owned by root with the setuid/setgid bit set
		then you may open your system to intrusion.

		You can only assign the setuid/setgid bit by explicitly defining permissions. 
		The character for the setuid/setguid bit is s.

		So do set the setuid/setguid bit on file2.sh you would issue the command 
			chmod g+s file2.sh.

		Sticky Bit Special Permissions
		------------------------------
		The sticky bit can be very useful in shared environment because when it has been assigned to the permissions on a directory it sets it so only file owner can rename or delete the said file.

		You can only assign the sticky bit by explicitly defining permissions. The character for the sticky bit is t.

		To set the sticky bit on a directory named dir1 you would issue the command 
			chmod +t dir1.
			Users with sticky bit permission would be able to add content into it but not delete.

		When Permissions Are Important
		------------------------------
		To some users of Mac- or Windows-based computers you don’t think about permissions, but those environments don’t focus so aggressively on user based rights on files unless you are in a corporate environment. But now you are running a Linux-based system and permission based security is simplified and can be easily used to restrict access as you please.

		So I will show you some documents and folders that you want to focus on and show you how the optimal permissions should be set.

		home directories– The users’ home directories are important because you do not want other users to be able to view and modify the files in another user’s documents of desktop. To remedy this you will want the directory to have the drwx______ (700) permissions, so lets say we want to enforce the correct permissions on the user user1’s home directory that can be done by issuing the command chmod 700 /home/user1.
		bootloader configuration files– If you decide to implement password to boot specific operating systems then you will want to remove read and write permissions from the configuration file from all users but root. To do you can change the permissions of the file to 700.
		system and daemon configuration files– It is very important to restrict rights to system and daemon configuration files to restrict users from  ing the contents, it may not be advisable to restrict read permissions, but restricting write permissions is a must. In these cases it may be best to modify the rights to 644.
		firewall scripts – It may not always be necessary to block all users from reading the firewall file, but it is advisable to restrict the users from writing to the file. In this case the firewall script is run by the root user automatically on boot, so all other users need no rights, so you can assign the 700 permissions.


	Other commands chgrp and chattr
	https://tecadmin.net/tutorial/linux/linux-file-permissions/
		chgrp - Change group ownership of a file or directory
    


	


	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Default file access permission: umask
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Outside syllabus: systemctl commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	The systemctl command is a new tool to control the systemd system and service. 
	Replacement of old SysV init system management. 
	Most of modern Linux operating systems are using this new tool. 
	
	systemctl [OPTION] [SERVICE]
	
	sudo systemctl start mysql.service
	sudo systemctl stop mysql.service
	
	
	sudo systemctl reload mysql.service
	sudo systemctl restart mysql.service
	sudo systemctl reload-or-restart mysql.service

	sudo systemctl status mysql.service
	sudo systemctl enable mysql.service
	sudo systemctl disable mysql.service
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LINKING FILES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Concept of file links, inode
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Types of linking files: hard links and soft/symbolic links
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Purpose of linking files
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
COMMUNICATION
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Offline & Online communication commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Sending mails
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Receiving mails
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Chatting using write
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Lab session
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PROCESS MANAGEMENT
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Concept of processes
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Process statistics: ps
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Child and parent processes
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Running process in background process - &
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Suspending process
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Resuming process in foreground/background mode
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Terminating process
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SCHEDULING PROCESS/JOB
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Terminal information
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Scheduling jobs: at
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Managing repeating jobs: crontab
		- listing
		- modifying
		- removing
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
Day – 3
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FILE ARCHIVE AND COMPRESSION
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• splitting and merging files
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• tape archive - tar
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	tar -xvf - Extract Files from a Tarball
	Command Example:
	 
	 
	 
	tar -xvf archive.tar
	Details:
	This command extracts the contents of the tar archive archive.tar.
	How it works:
	Reads the tar file and unpacks its contents into the current directory.
	Options:
	-C <directory>: Extract files to a specific directory.
	 
	 
	 
	tar -xvf archive.tar -C /path/to/destination
	
	tar -cvf - Create a tarball (archive) of files
    tar -tvf - List the contents of a tarball
    tar -xvf - Extract files from a tarball
    
	tar -czvf - Create a compressed tarball (gzip)
    tar -xzvf - Extract files from a compressed tarball (gzip)
    
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• File compression using gzip
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• File decompression using gunzip
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SED
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Syntax of sed Commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Print
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Substitution
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Delete
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Append, Insert, and Change
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Writing changes to file
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
AWK
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Getting Starting with awk
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Predefined variables of awk
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Doing arithmetic with awk
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• User Defined variables in awk
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Use of printf statement
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• In-built function
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Use of Format Specification Code
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• BEGIN & END constructs
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• if condition in awk
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Loops in awk
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Examples in awk
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SHELL Scripting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Shell Scripting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Environment Variables – env
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Types of shells: sh, ksh,  , csh, tcsh
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• System defined shell variables: $HOME, $USER, $LOGNAME, $PATH, etc.,
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• User defined variables: local and global shell variables
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Customizing Your Prompt
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Built-In Versus Linux Commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The   Hash Table
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The Set and Shopt Commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
SHELL SCRIPTS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• What is a Shell Script?
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Use of shell script
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Writing shell script
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Invoking scripts using sh
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Invoking scripts by granting execute permission
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Quoting mechanism
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Day – 4
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
POSITIONAL PARAMETERS/COMMANDLINE ARGUMENTS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Concept of command line arguments
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Positional parameters – $1, $2, …,$?, $#, $*, $@, $$
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• $? – exit status of program
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Shifting arguments - shift
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Setting Positional Parameters
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
EVALUATING CONDITIONS IN SHELL SCRIPTS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Conditional execution: test, [], [[ ]]
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	• Numeric comparison operators
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• String comparison operators
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Logical operations
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• File testing Operators
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Integer arithmetic – expr
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Floating number arithmetic - bc
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CONTROL FLOW STRUCTURES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The if-then-else Construct
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• if Example
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The Case Statement
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• case Code Example
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• SELECT example
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Conditional Loop syntax
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		o while loop Example
		o until Loop Example
		o for loop Example
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• /dev/null Logic
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• HERE document
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Lab session
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Day – 5
Array variables
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Creating array Variable
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Substituting and counting
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Using integer variables as element numbers
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Lab Session
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Writing script for
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		o performing backup of file interactively and using positional parameter
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		o logging into oracle database and performing spool
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		o file testing
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		o removing duplicate files
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Debugging shell script
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Lab session
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The 'getopts' Command
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Processing arguments
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The getopts and OPTARG variable
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The OPTIND variable
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Lab Session
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Traps, Signals and Script Control
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Common signals
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Running Scripts in Background Mode
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Scheduling your script
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Starting the Script at Boot Time
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• The trap commands
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Lab Session
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Other Utility Commands
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Listing CPU & Memory utilization using top command
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	• Network Basics:
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		o Internet Protocol
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		o Addressing – inet(IPv4), inet6(IPv6)
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	• Networking utilities: ping, telnet, ifconfig, netstat
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		o continue and break 
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	ping - Test Network Connectivity
		Command Example:
		 
		 
		 
		ping google.com
		Details:
		This command sends ICMP echo requests to google.com to test connectivity and measure response time.
		How it works:
		Displays the time taken for each packet to travel to the destination and back.
		Options:
		-c <count>: Limit the number of packets sent.
		 
		 
		 
		ping -c 5 google.com
		-i <interval>: Set the interval between packets.
		 
		 
		 
		ping -i 2 google.com